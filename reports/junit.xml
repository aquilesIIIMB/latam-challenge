<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="4" skipped="0" tests="4" time="0.915" timestamp="2025-03-04T23:48:55.200176" hostname="Aquiless-MacBook-Pro.local"><testcase classname="tests.model.test_model.TestModel" name="test_model_fit" time="0.001"><failure message="FileNotFoundError: [Errno 2] No such file or directory: '../data/data.csv'">self = &lt;tests.model.test_model.TestModel testMethod=test_model_fit&gt;

    def setUp(self) -&gt; None:
        super().setUp()
        self.model = DelayModel()
&gt;       self.data = pd.read_csv(filepath_or_buffer="../data/data.csv")

tests/model/test_model.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/util/_decorators.py:311: in wrapper
    return func(*args, **kwargs)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:586: in read_csv
    return _read(filepath_or_buffer, kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:482: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:811: in __init__
    self._engine = self._make_engine(self.engine)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:1040: in _make_engine
    return mapping[engine](self.f, **self.options)  # type: ignore[call-arg]
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/c_parser_wrapper.py:51: in __init__
    self._open_handles(src, kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/base_parser.py:222: in _open_handles
    self.handles = get_handle(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path_or_buf = '../data/data.csv', mode = 'r', encoding = 'utf-8', compression = None, memory_map = False, is_text = True, errors = 'strict', storage_options = None

    def get_handle(
        path_or_buf: FilePathOrBuffer,
        mode: str,
        encoding: str | None = None,
        compression: CompressionOptions = None,
        memory_map: bool = False,
        is_text: bool = True,
        errors: str | None = None,
        storage_options: StorageOptions = None,
    ) -&gt; IOHandles:
        """
        Get file handle for given path/buffer and mode.
    
        Parameters
        ----------
        path_or_buf : str or file handle
            File path or object.
        mode : str
            Mode to open path_or_buf with.
        encoding : str or None
            Encoding to use.
        compression : str or dict, default None
            If string, specifies compression mode. If dict, value at key 'method'
            specifies compression mode. Compression mode must be one of {'infer',
            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'
            and `filepath_or_buffer` is path-like, then detect compression from
            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise
            no compression). If dict and compression mode is one of
            {'zip', 'gzip', 'bz2'}, or inferred as one of the above,
            other entries passed as additional compression options.
    
            .. versionchanged:: 1.0.0
    
               May now be a dict with key 'method' as compression mode
               and other keys as compression options if compression
               mode is 'zip'.
    
            .. versionchanged:: 1.1.0
    
               Passing compression options as keys in dict is now
               supported for compression modes 'gzip' and 'bz2' as well as 'zip'.
    
        memory_map : bool, default False
            See parsers._parser_params for more information.
        is_text : bool, default True
            Whether the type of the content passed to the file/buffer is string or
            bytes. This is not the same as `"b" not in mode`. If a string content is
            passed to a binary file/buffer, a wrapper is inserted.
        errors : str, default 'strict'
            Specifies how encoding and decoding errors are to be handled.
            See the errors argument for :func:`open` for a full list
            of options.
        storage_options: StorageOptions = None
            Passed to _get_filepath_or_buffer
    
        .. versionchanged:: 1.2.0
    
        Returns the dataclass IOHandles
        """
        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior
        encoding = encoding or "utf-8"
    
        # read_csv does not know whether the buffer is opened in binary/text mode
        if _is_binary_mode(path_or_buf, mode) and "b" not in mode:
            mode += "b"
    
        # valdiate errors
        if isinstance(errors, str):
            errors = errors.lower()
        if errors not in (
            None,
            "strict",
            "ignore",
            "replace",
            "xmlcharrefreplace",
            "backslashreplace",
            "namereplace",
            "surrogateescape",
            "surrogatepass",
        ):
            raise ValueError(
                f"Invalid value for `encoding_errors` ({errors}). Please see "
                + "https://docs.python.org/3/library/codecs.html#error-handlers "
                + "for valid values."
            )
    
        # open URLs
        ioargs = _get_filepath_or_buffer(
            path_or_buf,
            encoding=encoding,
            compression=compression,
            mode=mode,
            storage_options=storage_options,
        )
    
        handle = ioargs.filepath_or_buffer
        handles: list[Buffer]
    
        # memory mapping needs to be the first step
        handle, memory_map, handles = _maybe_memory_map(
            handle,
            memory_map,
            ioargs.encoding,
            ioargs.mode,
            errors,
            ioargs.compression["method"] not in _compression_to_extension,
        )
    
        is_path = isinstance(handle, str)
        compression_args = dict(ioargs.compression)
        compression = compression_args.pop("method")
    
        if compression:
            # compression libraries do not like an explicit text-mode
            ioargs.mode = ioargs.mode.replace("t", "")
    
            # GZ Compression
            if compression == "gzip":
                if is_path:
                    assert isinstance(handle, str)
                    handle = gzip.GzipFile(
                        filename=handle,
                        mode=ioargs.mode,
                        **compression_args,
                    )
                else:
                    handle = gzip.GzipFile(
                        # error: Argument "fileobj" to "GzipFile" has incompatible type
                        # "Union[str, Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase,
                        # TextIOWrapper, mmap]]"; expected "Optional[IO[bytes]]"
                        fileobj=handle,  # type: ignore[arg-type]
                        mode=ioargs.mode,
                        **compression_args,
                    )
    
            # BZ Compression
            elif compression == "bz2":
                handle = bz2.BZ2File(
                    # Argument 1 to "BZ2File" has incompatible type "Union[str,
                    # Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase, TextIOWrapper,
                    # mmap]]"; expected "Union[Union[str, bytes, _PathLike[str],
                    # _PathLike[bytes]], IO[bytes]]"
                    handle,  # type: ignore[arg-type]
                    mode=ioargs.mode,
                    **compression_args,
                )
    
            # ZIP Compression
            elif compression == "zip":
                handle = _BytesZipFile(handle, ioargs.mode, **compression_args)
                if handle.mode == "r":
                    handles.append(handle)
                    zip_names = handle.namelist()
                    if len(zip_names) == 1:
                        handle = handle.open(zip_names.pop())
                    elif len(zip_names) == 0:
                        raise ValueError(f"Zero files found in ZIP file {path_or_buf}")
                    else:
                        raise ValueError(
                            "Multiple files found in ZIP file. "
                            f"Only one file per ZIP: {zip_names}"
                        )
    
            # XZ Compression
            elif compression == "xz":
                handle = get_lzma_file(lzma)(handle, ioargs.mode)
    
            # Unrecognized Compression
            else:
                msg = f"Unrecognized compression type: {compression}"
                raise ValueError(msg)
    
            assert not isinstance(handle, str)
            handles.append(handle)
    
        elif isinstance(handle, str):
            # Check whether the filename is to be opened in binary mode.
            # Binary mode does not support 'encoding' and 'newline'.
            if ioargs.encoding and "b" not in ioargs.mode:
                # Encoding
&gt;               handle = open(
                    handle,
                    ioargs.mode,
                    encoding=ioargs.encoding,
                    errors=errors,
                    newline="",
                )
E               FileNotFoundError: [Errno 2] No such file or directory: '../data/data.csv'

../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/common.py:702: FileNotFoundError</failure></testcase><testcase classname="tests.model.test_model.TestModel" name="test_model_predict" time="0.001"><failure message="FileNotFoundError: [Errno 2] No such file or directory: '../data/data.csv'">self = &lt;tests.model.test_model.TestModel testMethod=test_model_predict&gt;

    def setUp(self) -&gt; None:
        super().setUp()
        self.model = DelayModel()
&gt;       self.data = pd.read_csv(filepath_or_buffer="../data/data.csv")

tests/model/test_model.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/util/_decorators.py:311: in wrapper
    return func(*args, **kwargs)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:586: in read_csv
    return _read(filepath_or_buffer, kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:482: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:811: in __init__
    self._engine = self._make_engine(self.engine)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:1040: in _make_engine
    return mapping[engine](self.f, **self.options)  # type: ignore[call-arg]
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/c_parser_wrapper.py:51: in __init__
    self._open_handles(src, kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/base_parser.py:222: in _open_handles
    self.handles = get_handle(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path_or_buf = '../data/data.csv', mode = 'r', encoding = 'utf-8', compression = None, memory_map = False, is_text = True, errors = 'strict', storage_options = None

    def get_handle(
        path_or_buf: FilePathOrBuffer,
        mode: str,
        encoding: str | None = None,
        compression: CompressionOptions = None,
        memory_map: bool = False,
        is_text: bool = True,
        errors: str | None = None,
        storage_options: StorageOptions = None,
    ) -&gt; IOHandles:
        """
        Get file handle for given path/buffer and mode.
    
        Parameters
        ----------
        path_or_buf : str or file handle
            File path or object.
        mode : str
            Mode to open path_or_buf with.
        encoding : str or None
            Encoding to use.
        compression : str or dict, default None
            If string, specifies compression mode. If dict, value at key 'method'
            specifies compression mode. Compression mode must be one of {'infer',
            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'
            and `filepath_or_buffer` is path-like, then detect compression from
            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise
            no compression). If dict and compression mode is one of
            {'zip', 'gzip', 'bz2'}, or inferred as one of the above,
            other entries passed as additional compression options.
    
            .. versionchanged:: 1.0.0
    
               May now be a dict with key 'method' as compression mode
               and other keys as compression options if compression
               mode is 'zip'.
    
            .. versionchanged:: 1.1.0
    
               Passing compression options as keys in dict is now
               supported for compression modes 'gzip' and 'bz2' as well as 'zip'.
    
        memory_map : bool, default False
            See parsers._parser_params for more information.
        is_text : bool, default True
            Whether the type of the content passed to the file/buffer is string or
            bytes. This is not the same as `"b" not in mode`. If a string content is
            passed to a binary file/buffer, a wrapper is inserted.
        errors : str, default 'strict'
            Specifies how encoding and decoding errors are to be handled.
            See the errors argument for :func:`open` for a full list
            of options.
        storage_options: StorageOptions = None
            Passed to _get_filepath_or_buffer
    
        .. versionchanged:: 1.2.0
    
        Returns the dataclass IOHandles
        """
        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior
        encoding = encoding or "utf-8"
    
        # read_csv does not know whether the buffer is opened in binary/text mode
        if _is_binary_mode(path_or_buf, mode) and "b" not in mode:
            mode += "b"
    
        # valdiate errors
        if isinstance(errors, str):
            errors = errors.lower()
        if errors not in (
            None,
            "strict",
            "ignore",
            "replace",
            "xmlcharrefreplace",
            "backslashreplace",
            "namereplace",
            "surrogateescape",
            "surrogatepass",
        ):
            raise ValueError(
                f"Invalid value for `encoding_errors` ({errors}). Please see "
                + "https://docs.python.org/3/library/codecs.html#error-handlers "
                + "for valid values."
            )
    
        # open URLs
        ioargs = _get_filepath_or_buffer(
            path_or_buf,
            encoding=encoding,
            compression=compression,
            mode=mode,
            storage_options=storage_options,
        )
    
        handle = ioargs.filepath_or_buffer
        handles: list[Buffer]
    
        # memory mapping needs to be the first step
        handle, memory_map, handles = _maybe_memory_map(
            handle,
            memory_map,
            ioargs.encoding,
            ioargs.mode,
            errors,
            ioargs.compression["method"] not in _compression_to_extension,
        )
    
        is_path = isinstance(handle, str)
        compression_args = dict(ioargs.compression)
        compression = compression_args.pop("method")
    
        if compression:
            # compression libraries do not like an explicit text-mode
            ioargs.mode = ioargs.mode.replace("t", "")
    
            # GZ Compression
            if compression == "gzip":
                if is_path:
                    assert isinstance(handle, str)
                    handle = gzip.GzipFile(
                        filename=handle,
                        mode=ioargs.mode,
                        **compression_args,
                    )
                else:
                    handle = gzip.GzipFile(
                        # error: Argument "fileobj" to "GzipFile" has incompatible type
                        # "Union[str, Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase,
                        # TextIOWrapper, mmap]]"; expected "Optional[IO[bytes]]"
                        fileobj=handle,  # type: ignore[arg-type]
                        mode=ioargs.mode,
                        **compression_args,
                    )
    
            # BZ Compression
            elif compression == "bz2":
                handle = bz2.BZ2File(
                    # Argument 1 to "BZ2File" has incompatible type "Union[str,
                    # Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase, TextIOWrapper,
                    # mmap]]"; expected "Union[Union[str, bytes, _PathLike[str],
                    # _PathLike[bytes]], IO[bytes]]"
                    handle,  # type: ignore[arg-type]
                    mode=ioargs.mode,
                    **compression_args,
                )
    
            # ZIP Compression
            elif compression == "zip":
                handle = _BytesZipFile(handle, ioargs.mode, **compression_args)
                if handle.mode == "r":
                    handles.append(handle)
                    zip_names = handle.namelist()
                    if len(zip_names) == 1:
                        handle = handle.open(zip_names.pop())
                    elif len(zip_names) == 0:
                        raise ValueError(f"Zero files found in ZIP file {path_or_buf}")
                    else:
                        raise ValueError(
                            "Multiple files found in ZIP file. "
                            f"Only one file per ZIP: {zip_names}"
                        )
    
            # XZ Compression
            elif compression == "xz":
                handle = get_lzma_file(lzma)(handle, ioargs.mode)
    
            # Unrecognized Compression
            else:
                msg = f"Unrecognized compression type: {compression}"
                raise ValueError(msg)
    
            assert not isinstance(handle, str)
            handles.append(handle)
    
        elif isinstance(handle, str):
            # Check whether the filename is to be opened in binary mode.
            # Binary mode does not support 'encoding' and 'newline'.
            if ioargs.encoding and "b" not in ioargs.mode:
                # Encoding
&gt;               handle = open(
                    handle,
                    ioargs.mode,
                    encoding=ioargs.encoding,
                    errors=errors,
                    newline="",
                )
E               FileNotFoundError: [Errno 2] No such file or directory: '../data/data.csv'

../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/common.py:702: FileNotFoundError</failure></testcase><testcase classname="tests.model.test_model.TestModel" name="test_model_preprocess_for_serving" time="0.000"><failure message="FileNotFoundError: [Errno 2] No such file or directory: '../data/data.csv'">self = &lt;tests.model.test_model.TestModel testMethod=test_model_preprocess_for_serving&gt;

    def setUp(self) -&gt; None:
        super().setUp()
        self.model = DelayModel()
&gt;       self.data = pd.read_csv(filepath_or_buffer="../data/data.csv")

tests/model/test_model.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/util/_decorators.py:311: in wrapper
    return func(*args, **kwargs)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:586: in read_csv
    return _read(filepath_or_buffer, kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:482: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:811: in __init__
    self._engine = self._make_engine(self.engine)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:1040: in _make_engine
    return mapping[engine](self.f, **self.options)  # type: ignore[call-arg]
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/c_parser_wrapper.py:51: in __init__
    self._open_handles(src, kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/base_parser.py:222: in _open_handles
    self.handles = get_handle(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path_or_buf = '../data/data.csv', mode = 'r', encoding = 'utf-8', compression = None, memory_map = False, is_text = True, errors = 'strict', storage_options = None

    def get_handle(
        path_or_buf: FilePathOrBuffer,
        mode: str,
        encoding: str | None = None,
        compression: CompressionOptions = None,
        memory_map: bool = False,
        is_text: bool = True,
        errors: str | None = None,
        storage_options: StorageOptions = None,
    ) -&gt; IOHandles:
        """
        Get file handle for given path/buffer and mode.
    
        Parameters
        ----------
        path_or_buf : str or file handle
            File path or object.
        mode : str
            Mode to open path_or_buf with.
        encoding : str or None
            Encoding to use.
        compression : str or dict, default None
            If string, specifies compression mode. If dict, value at key 'method'
            specifies compression mode. Compression mode must be one of {'infer',
            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'
            and `filepath_or_buffer` is path-like, then detect compression from
            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise
            no compression). If dict and compression mode is one of
            {'zip', 'gzip', 'bz2'}, or inferred as one of the above,
            other entries passed as additional compression options.
    
            .. versionchanged:: 1.0.0
    
               May now be a dict with key 'method' as compression mode
               and other keys as compression options if compression
               mode is 'zip'.
    
            .. versionchanged:: 1.1.0
    
               Passing compression options as keys in dict is now
               supported for compression modes 'gzip' and 'bz2' as well as 'zip'.
    
        memory_map : bool, default False
            See parsers._parser_params for more information.
        is_text : bool, default True
            Whether the type of the content passed to the file/buffer is string or
            bytes. This is not the same as `"b" not in mode`. If a string content is
            passed to a binary file/buffer, a wrapper is inserted.
        errors : str, default 'strict'
            Specifies how encoding and decoding errors are to be handled.
            See the errors argument for :func:`open` for a full list
            of options.
        storage_options: StorageOptions = None
            Passed to _get_filepath_or_buffer
    
        .. versionchanged:: 1.2.0
    
        Returns the dataclass IOHandles
        """
        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior
        encoding = encoding or "utf-8"
    
        # read_csv does not know whether the buffer is opened in binary/text mode
        if _is_binary_mode(path_or_buf, mode) and "b" not in mode:
            mode += "b"
    
        # valdiate errors
        if isinstance(errors, str):
            errors = errors.lower()
        if errors not in (
            None,
            "strict",
            "ignore",
            "replace",
            "xmlcharrefreplace",
            "backslashreplace",
            "namereplace",
            "surrogateescape",
            "surrogatepass",
        ):
            raise ValueError(
                f"Invalid value for `encoding_errors` ({errors}). Please see "
                + "https://docs.python.org/3/library/codecs.html#error-handlers "
                + "for valid values."
            )
    
        # open URLs
        ioargs = _get_filepath_or_buffer(
            path_or_buf,
            encoding=encoding,
            compression=compression,
            mode=mode,
            storage_options=storage_options,
        )
    
        handle = ioargs.filepath_or_buffer
        handles: list[Buffer]
    
        # memory mapping needs to be the first step
        handle, memory_map, handles = _maybe_memory_map(
            handle,
            memory_map,
            ioargs.encoding,
            ioargs.mode,
            errors,
            ioargs.compression["method"] not in _compression_to_extension,
        )
    
        is_path = isinstance(handle, str)
        compression_args = dict(ioargs.compression)
        compression = compression_args.pop("method")
    
        if compression:
            # compression libraries do not like an explicit text-mode
            ioargs.mode = ioargs.mode.replace("t", "")
    
            # GZ Compression
            if compression == "gzip":
                if is_path:
                    assert isinstance(handle, str)
                    handle = gzip.GzipFile(
                        filename=handle,
                        mode=ioargs.mode,
                        **compression_args,
                    )
                else:
                    handle = gzip.GzipFile(
                        # error: Argument "fileobj" to "GzipFile" has incompatible type
                        # "Union[str, Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase,
                        # TextIOWrapper, mmap]]"; expected "Optional[IO[bytes]]"
                        fileobj=handle,  # type: ignore[arg-type]
                        mode=ioargs.mode,
                        **compression_args,
                    )
    
            # BZ Compression
            elif compression == "bz2":
                handle = bz2.BZ2File(
                    # Argument 1 to "BZ2File" has incompatible type "Union[str,
                    # Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase, TextIOWrapper,
                    # mmap]]"; expected "Union[Union[str, bytes, _PathLike[str],
                    # _PathLike[bytes]], IO[bytes]]"
                    handle,  # type: ignore[arg-type]
                    mode=ioargs.mode,
                    **compression_args,
                )
    
            # ZIP Compression
            elif compression == "zip":
                handle = _BytesZipFile(handle, ioargs.mode, **compression_args)
                if handle.mode == "r":
                    handles.append(handle)
                    zip_names = handle.namelist()
                    if len(zip_names) == 1:
                        handle = handle.open(zip_names.pop())
                    elif len(zip_names) == 0:
                        raise ValueError(f"Zero files found in ZIP file {path_or_buf}")
                    else:
                        raise ValueError(
                            "Multiple files found in ZIP file. "
                            f"Only one file per ZIP: {zip_names}"
                        )
    
            # XZ Compression
            elif compression == "xz":
                handle = get_lzma_file(lzma)(handle, ioargs.mode)
    
            # Unrecognized Compression
            else:
                msg = f"Unrecognized compression type: {compression}"
                raise ValueError(msg)
    
            assert not isinstance(handle, str)
            handles.append(handle)
    
        elif isinstance(handle, str):
            # Check whether the filename is to be opened in binary mode.
            # Binary mode does not support 'encoding' and 'newline'.
            if ioargs.encoding and "b" not in ioargs.mode:
                # Encoding
&gt;               handle = open(
                    handle,
                    ioargs.mode,
                    encoding=ioargs.encoding,
                    errors=errors,
                    newline="",
                )
E               FileNotFoundError: [Errno 2] No such file or directory: '../data/data.csv'

../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/common.py:702: FileNotFoundError</failure></testcase><testcase classname="tests.model.test_model.TestModel" name="test_model_preprocess_for_training" time="0.000"><failure message="FileNotFoundError: [Errno 2] No such file or directory: '../data/data.csv'">self = &lt;tests.model.test_model.TestModel testMethod=test_model_preprocess_for_training&gt;

    def setUp(self) -&gt; None:
        super().setUp()
        self.model = DelayModel()
&gt;       self.data = pd.read_csv(filepath_or_buffer="../data/data.csv")

tests/model/test_model.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/util/_decorators.py:311: in wrapper
    return func(*args, **kwargs)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:586: in read_csv
    return _read(filepath_or_buffer, kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:482: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:811: in __init__
    self._engine = self._make_engine(self.engine)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/readers.py:1040: in _make_engine
    return mapping[engine](self.f, **self.options)  # type: ignore[call-arg]
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/c_parser_wrapper.py:51: in __init__
    self._open_handles(src, kwds)
../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/parsers/base_parser.py:222: in _open_handles
    self.handles = get_handle(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path_or_buf = '../data/data.csv', mode = 'r', encoding = 'utf-8', compression = None, memory_map = False, is_text = True, errors = 'strict', storage_options = None

    def get_handle(
        path_or_buf: FilePathOrBuffer,
        mode: str,
        encoding: str | None = None,
        compression: CompressionOptions = None,
        memory_map: bool = False,
        is_text: bool = True,
        errors: str | None = None,
        storage_options: StorageOptions = None,
    ) -&gt; IOHandles:
        """
        Get file handle for given path/buffer and mode.
    
        Parameters
        ----------
        path_or_buf : str or file handle
            File path or object.
        mode : str
            Mode to open path_or_buf with.
        encoding : str or None
            Encoding to use.
        compression : str or dict, default None
            If string, specifies compression mode. If dict, value at key 'method'
            specifies compression mode. Compression mode must be one of {'infer',
            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'
            and `filepath_or_buffer` is path-like, then detect compression from
            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise
            no compression). If dict and compression mode is one of
            {'zip', 'gzip', 'bz2'}, or inferred as one of the above,
            other entries passed as additional compression options.
    
            .. versionchanged:: 1.0.0
    
               May now be a dict with key 'method' as compression mode
               and other keys as compression options if compression
               mode is 'zip'.
    
            .. versionchanged:: 1.1.0
    
               Passing compression options as keys in dict is now
               supported for compression modes 'gzip' and 'bz2' as well as 'zip'.
    
        memory_map : bool, default False
            See parsers._parser_params for more information.
        is_text : bool, default True
            Whether the type of the content passed to the file/buffer is string or
            bytes. This is not the same as `"b" not in mode`. If a string content is
            passed to a binary file/buffer, a wrapper is inserted.
        errors : str, default 'strict'
            Specifies how encoding and decoding errors are to be handled.
            See the errors argument for :func:`open` for a full list
            of options.
        storage_options: StorageOptions = None
            Passed to _get_filepath_or_buffer
    
        .. versionchanged:: 1.2.0
    
        Returns the dataclass IOHandles
        """
        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior
        encoding = encoding or "utf-8"
    
        # read_csv does not know whether the buffer is opened in binary/text mode
        if _is_binary_mode(path_or_buf, mode) and "b" not in mode:
            mode += "b"
    
        # valdiate errors
        if isinstance(errors, str):
            errors = errors.lower()
        if errors not in (
            None,
            "strict",
            "ignore",
            "replace",
            "xmlcharrefreplace",
            "backslashreplace",
            "namereplace",
            "surrogateescape",
            "surrogatepass",
        ):
            raise ValueError(
                f"Invalid value for `encoding_errors` ({errors}). Please see "
                + "https://docs.python.org/3/library/codecs.html#error-handlers "
                + "for valid values."
            )
    
        # open URLs
        ioargs = _get_filepath_or_buffer(
            path_or_buf,
            encoding=encoding,
            compression=compression,
            mode=mode,
            storage_options=storage_options,
        )
    
        handle = ioargs.filepath_or_buffer
        handles: list[Buffer]
    
        # memory mapping needs to be the first step
        handle, memory_map, handles = _maybe_memory_map(
            handle,
            memory_map,
            ioargs.encoding,
            ioargs.mode,
            errors,
            ioargs.compression["method"] not in _compression_to_extension,
        )
    
        is_path = isinstance(handle, str)
        compression_args = dict(ioargs.compression)
        compression = compression_args.pop("method")
    
        if compression:
            # compression libraries do not like an explicit text-mode
            ioargs.mode = ioargs.mode.replace("t", "")
    
            # GZ Compression
            if compression == "gzip":
                if is_path:
                    assert isinstance(handle, str)
                    handle = gzip.GzipFile(
                        filename=handle,
                        mode=ioargs.mode,
                        **compression_args,
                    )
                else:
                    handle = gzip.GzipFile(
                        # error: Argument "fileobj" to "GzipFile" has incompatible type
                        # "Union[str, Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase,
                        # TextIOWrapper, mmap]]"; expected "Optional[IO[bytes]]"
                        fileobj=handle,  # type: ignore[arg-type]
                        mode=ioargs.mode,
                        **compression_args,
                    )
    
            # BZ Compression
            elif compression == "bz2":
                handle = bz2.BZ2File(
                    # Argument 1 to "BZ2File" has incompatible type "Union[str,
                    # Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase, TextIOWrapper,
                    # mmap]]"; expected "Union[Union[str, bytes, _PathLike[str],
                    # _PathLike[bytes]], IO[bytes]]"
                    handle,  # type: ignore[arg-type]
                    mode=ioargs.mode,
                    **compression_args,
                )
    
            # ZIP Compression
            elif compression == "zip":
                handle = _BytesZipFile(handle, ioargs.mode, **compression_args)
                if handle.mode == "r":
                    handles.append(handle)
                    zip_names = handle.namelist()
                    if len(zip_names) == 1:
                        handle = handle.open(zip_names.pop())
                    elif len(zip_names) == 0:
                        raise ValueError(f"Zero files found in ZIP file {path_or_buf}")
                    else:
                        raise ValueError(
                            "Multiple files found in ZIP file. "
                            f"Only one file per ZIP: {zip_names}"
                        )
    
            # XZ Compression
            elif compression == "xz":
                handle = get_lzma_file(lzma)(handle, ioargs.mode)
    
            # Unrecognized Compression
            else:
                msg = f"Unrecognized compression type: {compression}"
                raise ValueError(msg)
    
            assert not isinstance(handle, str)
            handles.append(handle)
    
        elif isinstance(handle, str):
            # Check whether the filename is to be opened in binary mode.
            # Binary mode does not support 'encoding' and 'newline'.
            if ioargs.encoding and "b" not in ioargs.mode:
                # Encoding
&gt;               handle = open(
                    handle,
                    ioargs.mode,
                    encoding=ioargs.encoding,
                    errors=errors,
                    newline="",
                )
E               FileNotFoundError: [Errno 2] No such file or directory: '../data/data.csv'

../../../../miniconda3/envs/latam-challenge/lib/python3.9/site-packages/pandas/io/common.py:702: FileNotFoundError</failure></testcase></testsuite></testsuites>